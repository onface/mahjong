# mahjong

> “连连看”考验的是各位的眼力，在有限的时间内，只要把所有能连接的相同图案，两个一对地找出来，每找出一对，它们就会自动消失，只要把所有的图案全部消完即可获得胜利。所谓能够连接，指得是无论横向或者纵向，从一个图案到另一个图案之间的连线不能超过两个弯（不超过三条线），其中，连线不能从尚未消去的图案上经过。

## 记录逻辑实现过程

> 记录实现过程的目的是找出逻辑实现方法论

## 生成地图

根据元素生成初始随机地图，确保元素可被连接。

需要思考如何生产随机地图，确保不会出现死局（玩家可错误无限次且无线时间也无法破解称之为死局）

思考结果：遍历数据，将数据成对且随机的放置在地图中，每放置一对数据验证数据是否连接。最终图案能全部填充则此逻辑可行。

### 人为实现验证逻辑

```
# 逻辑列表
1. 复制 `data` 中的图案
2. 粘贴进 `map` 中的随机位置
3. 每填入一对数据检查这对数据是否可以连接（不超过三条线）
```

通过人为填充确定生成随机地图的逻辑可行

```js
//图案使用 abcdefghijkl­mnopqrstuvw­xyz@# (28个字)
// 7*8 的格子(共56个格子) 28*2=56
var map = [
    [' ',' ',' ',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' '],
    [' ',' ',' ',' ',' ',' ',' ']
]
var data = 'abcdefghijkl­mnopqrstuvw­xyz@#abcdefghijkl­mnopqrstuvw­xyz@#'


#### 出现死局 1

人为实现过程中遇到死局

```js
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ','a',' ',' ',' ',' '],
[' ','b',' ','b',' ',' ',' '],
[' ',' ','a',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' ']
```

改造人为实现：

```diff
# 逻辑列表
1. 复制 `data` 中的图案
2. 粘贴进 `map` 中的随机位置
+ 3. 判断粘贴后是否会出现四个图案包裹一个空位, 出现则继续随机寻找其他空位。
4. 每填入一对数据检查这对数据是否可以连接（不超过三条线）
```

> 人为验证阶段不要考虑代码如何实现，只需要考虑人为实现过程是否按照逻辑列表执行,

但是还有下面这种情况，四周的位置虽然出现了空位，但是他有可能连接的

```js
[' ',' ','a',' ','b',' ',' '],
[' ',' ',' ','a','b',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' ']

[' ',' ','a','c','b','c',' '],
[' ',' ',' ','a','b',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' '],
[' ',' ',' ',' ',' ',' ',' ']
```

#### 改造地图

经过思考，发现地图四周是有一个不可放置，但可寻路的区域。

```js
['*', '*', '*', '*', '*', '*', '*', '*', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*']
['*', '*', '*', '*', '*', '*', '*', '*', '*']
```

改造人为实现

**给 map 四周加上不可放置，但可寻路的区域**

```shell
*  *   *   *   *   *   *   *  *
*  -   -   -   -   -   -   -  *
*  -   -   -   -   -   -   -  *
*  -   -   -   -   -   -   -  *
*  -   -   -   -   -   -   -  *
*  -   -   -   -   -   -   -  *
*  -   -   -   -   -   -   -  *
*  -   -   -   -   -   -   -  *
*  -   -   -   -   -   -   -  *
*  *   *   *   *   *   *   *  *
```

在人为实现的过程中发现了一个小技巧：复制 a 到随机位置，上下左右移动光标，切换上下左右不能超过三次则等于不超过三条线。


### 出现死局2

```js
­mnopqrstuvw­xyz@#
*  *   *   *   *   *   *   *  *
*  -   -   -   -   -   i   -  *
*  -   a   -   -   -   -   -  *
*  -   -   e   c   f   -   -  *
*  b   k   l   -   k   -   h  *
*  -   g   -   -   d   j   -  *
*  -   d   -   -   -   a   -  *
*  -   h   l   -   e   b   -  *
*  c   g   i   j   f   -   -  *
*  *   *   *   *   *   *   *  *

nopqrstuvw­xyz@#
*  *   *   *   *   *   *   *  *
*  -   -   -   -   -   i   -  *
*  -   a   -   -   -   -   -  *
*  -   -   e   c   f   -   -  *
*  b   k   l   -   k   -   h  *
*  -   g   m   -   d   j   -  * // 变化：填充m
*  -   d   -   -   -   a   -  *
*  -   h   l   m   e   b   -  * // 变化：填充m
*  c   g   i   j   f   -   -  *
*  *   *   *   *   *   *   *  *

opqrstuvw­xyz@#
*  *   *   *   *   *   *   *  *
*  -   -   -   -   -   i   -  *
*  -   a   -   -   -   -   -  *
*  -   -   e   c   f   -   -  *
*  b   k   l   n   k   -   h  * // 变化：填充n
*  -   g   m   -   d   j   -  *
*  -   d   n   -   -   a   -  * // 变化：填充n 此时死局已经无法避免！
*  -   h   l   m   e   b   -  *
*  c   g   i   j   f   -   -  *
*  *   *   *   *   *   *   *  *

pqrstuvw­xyz@#
*  *   *   *   *   *   *   *  *
*  -   -   -   -   -   i   -  *
*  -   a   -   -   -   -   -  *
*  -   -   e   c   f   -   -  *
*  b   k   l   n   k   -   h  *
*  -   g   m   o   d   j   -  * // 变化：填充o
*  -   d   n   o   -   a   -  * // 变化：填充o  出现死局！
*  -   h   l   m   e   b   -  *
*  c   g   i   j   f   -   -  *
*  *   *   *   *   *   *   *  *
```

分析：一旦字母围住一个区域，且被围住的区域数量为奇数时就已经是死局

改造人为实现

```diff
# 逻辑列表
1. 复制 `data` 中的图案
2. 粘贴进 `map` 中的随机位置
- 3. 判断粘贴后是否会出现四个图案包裹一个空位, 出现则继续随机寻找其他空位。
+ 3. 判断粘贴后是否会出现被围住的区域，且区域数量为奇数。 出现则继续随机寻找其他空位。
4. 每填入一对数据检查这对数据是否可以连接（不超过三条线）
```

改造后人为实现逻辑工作量加大，大到难以人为验证。得到结论，当计算量大时无法使用人为验证方法。但计算量小的逻辑中人为验证方法可快速验证逻辑是否可行，是否要改善。

> 另外，可能地图生成没有最优解（100%生成非死局地图）。只要实现不100%生成死局的算法则可以反复计算知道拿到非死局结果。暂时不通过搜索引擎找是否有最优解，继续思考以找到逻辑实现方法论。


被围住的判断条件是：空位可以达到任意其他空位则该空位没有被围住。
